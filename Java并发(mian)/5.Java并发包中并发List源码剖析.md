# 第5章 Java并发包中并发List源码剖析

------

[TOC]

------

## 1. 介绍

​		并发包中的并发List只有CopyOnWriteArrayList.CopyOnWriteArrayList是一个线程安全的ArrayList,对其进行的修改操作都是在底层的一个复制的数组上进行的,也就是采取了写时复制策略.并使用ReentrantLock独占锁解决了修改时的并发问题.

## 2. 主要方法源码解析

### (1). 初始化

-   CopyOnWriteArrayList():无参构造,创建一个大小为0的数组所为初始值
-   CopyOnWriteArrayList(E[] toCopyIn):参数为数组,直接使用Arrays.copyOf()复制到CopyOnWriteArrayList内部的数组中
-   CopyOnWriteArrayList(Collection<> c):参数为集合,如果传入就是CopyOnWriteArrayList对象,直接使用其内部的数组复制为新对象的数组.如果传入的集合可以转为数组,将转换而来的数组复制为内部数组(集合实现的转化).如果都不行,使用Arrays.copyOf()进行复制.

### (2). 添加元素

-   boolean add(E e)

​		线程会先去回去独占锁,然后获取array,并将其复制到一个新数组.把新增的元素添加到新数组,最后使用新数组替换原数组,在方法返回前释放锁.

### (3). 获取指定位置元素

-   E get(int index)

​		不会进行枷锁同步,可能导致一个线程读取值时,另一个线程进行删除值的操作.但是删除时读取线程并不知道,因为删除在整个动作完成之前是在复制而来的副本中进行的.就可能读取到脏数据.这就是写时复制策略产生的弱一致问题.

### (4). 修改制定元素

-   E set(int index,E element)

​		先获取锁,复制为新数组,在新数组上修改,将新数组设置到array.

### (5). 删除元素

-   E remove(int index)

​		获取锁,将其他元素复制到新数组,讲新数组设置到array.

### (6). 弱一致性的迭代器

​		所为弱一致性是指返回迭代器后,其他线程对list的增删改对迭代器是不可见的.

​		生成迭代器后,如果对原数据进行了修改,通过之前的方法解读我们可以知道,只要修改了数组,就会使用新的数组替换原来的数组.那么即使迭代器使用的是指针传递的引用,原数组已经不被使用了,所以迭代器只能使用在生成迭代器时的快照数据.

## 3. 总结

​		CopyOnWriteArrayList使用写时复制策略来保证一致性,但是获取-修改-写入三个操作不是原子的,所以在增删改是都使用了独占锁保证同时只能有一个线程对CopyOnWriteArrayList进行修改.

