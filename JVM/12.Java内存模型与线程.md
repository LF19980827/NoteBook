# 第12章 Java内存模型与线程

------

[TOC]

------

## 1、 硬件的效率与一致性

​		由于计算机的存储设备与处理器的运算速度有几个数量级的差距,所以现代计算机系统不得不加入一层读写速度尽可能接近处理器运算速度的**高速缓存**来作为内存与处理器之间的缓冲:将运算需要用到的数据复制到缓存中,当运算结束后在从缓存中同步到内存中.

​		除了增加高速缓存之外,为了使处理器内部的运算单元能尽量被充分被利用,处理器可能会对输入代码进行乱序执行优化,但前提是保证程序运行的结果与顺序执行的结果是一致性的,只是各个语句的执行顺序可能与输入代码不一致.Java虚拟机的即时编译器中也有类似的指令重排序优化.

## 2、 Java内存模型

​		Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异,以实现让Java程序在各种平台下都能达到一致的内存访问效果.这个模型必须定义的足够严谨,才能让Java的并发内存访问操作不会产生歧义.但同时也必须定义的足够宽松,使得虚拟机的实现有顾邹的自由空间去利用硬件的各种特性来获取更好的执行速度.

### 2.1 主内存与工作内存

​		Java内存模型的主要目标是定义程序中各个变量的访问规则,即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节.这里的变量包括实例字段,静态字段和构成数组对象的元素,不包括局部变量和方法参数,因为后者是线程私有的,不存在竞争问题.

​		Java内存模型规定了所有的变量都存储在主内存(类比物理硬件中的主内存).同时每条线程还有自己的工作内存(类比高速缓存),线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝,线程对变量的所有操作都必须在工作内存中进行,而不能直接对主内存进行读写.不同线程之间不能直接访问对方工作内存中的变量,线程见变量值的传递均需要通过主内存来进行过渡.

​		主内存主要对应于Java对中的对象实例数据部分,而工作内存则对应于虚拟机栈中的部分区域.更低层面上讲,主内存直接对应于物理硬件的内存,工作内存优先存储于寄存器和高速缓存中.

### 2.2 内存间交互操作

​		主内存与工作内存之间具体的交互协议,Java内存模型中定义了一下8种操作来完成,虚拟机是现实必须保证下面提及的每一中操作都是原子的,不可再分的.

-   lock(锁定):作用于主内存的变量,将一个变量标识为一个线程独占的状态
-   unlock(解锁):所用于主内存的变量,把一个处于锁定状态的变量释放出来
-   read(读取):作用于主内存的变量,把一个变量的值从主内存传输到线程的工作内存
-   load(载入):作用于工作内存的变量,把read操作传输到工作内存的变量值放入工作内存中的变量副本中
-   use(使用):作用于工作内存的变量,把工作内存中一个变量的值传递给执行引擎
-   assign(赋值):作用于工作内存的变量,把一个从执行引擎接收到的值赋值给工作内存中的一个变量
-   store(存储):作用于工作内存的变量,把工作内存的一个变量值传送到主内存
-   write(写入):作用于主内存的变量,把store操作传来的变量值放入主内存的变量中

​		而这8种操作在执行时必须满足以下规则:

-   read和load,store和write必须成对出现
-   在进行assign操作后,必须同步到主内存
-   不允许无缘无故的将工作内存中的变量值同步回主内存
-   新变量只能从主内存中诞生,工作内存中不允许使用一个未初始化的变量,所有变量都来自主内存
-   一个变量在同一时刻只允许一条线成对其进行lock操作,但lock操作可以被一个线程执行多次
-   如果对一个变量执行lock操作,将会清空工作内存中此变量的值,使用这个变量之前要先在主内存中复制
-   如果一个对象没有被执行过lock操作,就不能执行unlock操作
-   对一个变量记性unlock操作时,不许先把此变量同步回主内存

### 2.3 对于volatile型变量的特殊规则

​		当一个变量定义为volatile后,它将具备两种特性.

​		第一是保证此变量对所有线程的**可见性**,这里的可见性是指当一个线程修改了这个变量的值,则对于其他所有线程是可以立即得知的.(在各个工作内存中并不是立即同步,但在使用之前一定会进行同步,所以可以认为不存在一致性问题,但是Java中的运算不是原子操作,在并发情况下volatile变量仍然是不安全的)

​		由于volatile变量只能保证可见性,在不符合一下规则的情况下,仍然需要加锁来保证原子性:

-   运算结果并不依赖变量的当前自,或者说只有单一线程能改变变量的值
-   变量不需要与其他的状态变量共同参与不变约束

​		第二个语义是**禁止指令重排序**优化,更改顺序会导致在其他线程中volatile变量的值的改变时间变得随机

​		有volatile修饰的变量在赋值后会多执行一个lock add $0x0, (%esp)的操作,这个操作相当于一个内存屏障.只有一个cpu访问内存时并不需要内存屏障,但如果有多个cpu访问同一块内存,就需要内存屏障了.

​		add $0x0, (%esp)是一个空操作,关在在于lock前缀.它的作用是使本cpu的cache写入了内存,相当于对cache中的变量进行一次store和write操作.

​		因此这个指令将修改同步到内存时,意味着之前的操作都已经执行完成,形成了"指令重排序无法越过内存屏障"的效果.

### 2.4 对于long和double型变量的特殊规则

​		允许虚拟机实现选择可以不保证64为数据类型的load,store,read和write这4中操作的原子性,但目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待.

### 2.5 原子性,可见性和有序性

​		Java内存模型是围绕着在开发过程中如何处理原子性,可见性和有序性这3个特征来建立的.

-   原子性:由Java内存模型来直接保证的原子性变量操作包括read,load,assign,use,store和write.我们大致可以认为基本数据类型的访问读写是具备原子性的.如果应用场景需要一个更大范围的原子性保证,Java内存模型提供了lock和unlock操作.
-   可见性:可见性是指当一个线程修改了共享变量的值,其他线程能够立即得知这个值的修改.
-   有序性:Java程序中天然的有序性可以总结为一句话,如果在本线程内观察,所有的操作都是有序的,如果在另一个线程中观察,所有的操作都是无序的.

### 2.6 先行发生原则

​		先行发生的原则非常重要,它是判断数据是否存在竞争,线程是否安全的主要依据,依靠这个原则,我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题.

​		先行发生是Java内存模型中定义的两项操作之间的偏序关系,如果说操作A先行发生与操作B,操作A产生的影响能被操作B观察到.

​		下面是Java内存模型下一些天然的先行发生关系:

-   程序次序规则:一个线程内按照程序代码顺序,先写的操作先行发生于后写的操作.
-   管程锁定规则:一个unlock操作先行发生于后面对同一个锁的lock操作.
-   volatile变量规则:对一个volatile变量的写操作先行发生于对这个变量的读操作.
-   线程启动规则:Thread对象的start()方法先行发生于此线程的每一个动作.
-   线程终止规则:线程中的所有操作都线性发生于对此线程的终止检测.
-   线程终端规则:对象成interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生.
-   对象终结规则:一个对象的初始化完成先行发生于它的finalize()方法的开始.
-   传递性:如果操作A先行发生于操作B,操作B先行发生于操作C,那么操作A先行发生于操作C.

## 3、 Java与线程

​		Java里面谈论并发,多数都与线程脱不开关系.

### 3.1 线程的实现

​		线程是比进程更轻量级的调度执行单位,线程的引入,可以把一个进程的资源分配和执行调度分开,各个线程既可以共享进程资源,又可以独立调度.

​		Java语言提供了在不同硬件和操作系统平台下对线程操作的统一处理,每一个已经执行start()还未结束的java.lang.Thread类的实例就代表了一个线程.它的所有关键方法都是声明为Native的.

​		实现线程主要有3中方式:使用内核线程实现,使用用户线程实现和使用用户线程加轻量级进程混合实现.

#### 1). 使用内核线程实现

​		直接用操作系用内核支持的线程,这种线程由内核来完成线程切换,内核通过操纵调度器对线程进行调度,并负责讲线程的任务映射到各个处理器上,每一个内核线程可以视为内核的一个分身.

​		程序一般不会直接去直接使用内核线程,而是去使用内核线程的一种高级接口--轻量级进程,就是我们通常意义上的线程,每个轻量级进程都有一个内核线程支持.

​		由于内核线程的支持,每一个轻量级进程都成为一个独立的调度单元,即时有一个轻量级进程在系统调度中阻塞了,也不会影响整个进程继续工作.

​		局限性:由于是基于内核线程实现的,所以各种线程操作都需要进行需用调用,代价较高,需要在用户态和内核态中来回切换.其次,每个轻量级进程都需要有一个内核线程的支持,因此需要消耗一定的内核资源.

#### 2). 使用用户线程实现

​		从广义上讲,一个线程只要不是内核线程,就可以认为是用户线程,所以轻量级进程也属于用户进程,但平良机进程的实现始终是建立在内核之上的,许多操作都要进行系统调用,效率也会受到限制.

​		狭义上的用户线程指的是完全建立在用户空间的线程库上,系统内核不能感知存在的实现.用户线程的建立,同步,销毁和调度完全在用户态中完成,不需要内核的帮助.

​		这种线程不需要切换到内核态,因此操作可以使非常快速并且低耗的,也可以支持规模更大的线程数量,部分高性能数据库就是这样实现的.

​		优势在于不需要系统内核支援,快速低耗,却迪奥在于没有内核的支援,所有的线程操作都需要用户程序自己处理.

​		使用用户线程实现的程序一般都比较复杂,以致于越来越少.

#### 3). 使用用户线程加轻量级进程混合实现

​		这种混合实现下,既存在用户线程,也存在轻量级进程.用户线程还是完全建立在用户空间中,所以用户线程的创建,切换,析构等操作依然廉价,并且可以支持大规模的用户线程并发.而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁,这样可以使用内核提供的线程调度功能及处理器映射,并且用户线程的系统调用要通过轻量级线程来完成,大大降低了整个进程被完全阻塞的风险.

#### 4). Java线程的实现

​		早期JDK 1.2之前,基于用户线程实现,而在JDK 1.2中替换为基于操作系统原生线程模型来实现,因此目前的JDK版本中线程模型与操作以系统的支持有很大关系.

### 3.2 Java线程调度

​		线程调度是指系统为线程分配处理器使用权的过程,主要翘度方式有两种,分别是协同式线程调度和抢占式线程调度.

​		使用协同式调度的多线程系统,线程的执行时间由线程本身空值,当工作内容执行完成之后主动通知系统切换到另外一个线程上.好处是实现简单,切换对当前线程是可知的,没有什么线程同步问题.坏处是线程执行时间不可控,如果当前线程一直不退出,程序就可能崩溃.

​		使用抢占式调度的多线程系统,每个线程将有系统来分配执行时间,线程的切换不有线程本身来决定.线程的执行时间是系统可控的,也不会有一个线程导致整个进程阻塞的问题.这也是Java使用的线程调度方式.

​		Java线程调度是系统完成的,但可以设置线程优先级来让系统偏向于某些线程分配时间.当两个线程都处于ready状态时,优先级越高的线程越容易被系统线程选择执行.

​		不改线程优先级并不是很靠谱,一是虽然现在很多操作系统都提供线程优先级的概念,但并不一定能和Java线程的优先级一一对应.二是优先级可能会被操作系统自行改变.

### 3.3 状态转换

​		Java语言定义了5中线程状态:

-   新建:创建后未启动的线程
-   运行:包括操作系统线程状态中的Running和Ready,也就是说,这个线程可能正在执行也可能正在等着CPU给它分配时间.
-   无限期等待:处于这种状态的线程不会被分配cpu执行时间,需要等待被其他线程显式唤醒.以下方法可以达到这种状态:
    -   没有设置时间的Object.wait()方法
    -   没有设置时间的Thread.join()方法
    -   LockSupport.park()方法
-   限期等待:无需其他线程显式唤醒,一定时间过后由系统自动唤醒.以下方法可以达到这种状态:
    -   设置时间的Object.wait()方法
    -   设置时间的Thread.join()方法
    -   Thread.sleep()方法
    -   LockSupport.parkNanos()方法
    -   LockSupport.parkUntil()方法
-   阻塞:线程被阻塞了,与等待状态的区别是,阻塞状态只是在等待获取到一个排他锁,这个时间讲在另外一个线层放弃这个锁时发生
-   结束:已终止线程的状态,线程已经结束执行.