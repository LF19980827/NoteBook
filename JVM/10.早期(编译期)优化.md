-   # 第十章 早期(编译期)优化

------

[TOC]

------

## 1、 概述

​		Java语言的编译期是一个模糊的定义.可能是指一个前端编译期吧\*.java文件转变为\*.class文件的过程,也可能是虚拟机的后端运行期编译期(JIT)将字节码文件转变为机器码的过程,还可能是指使用静态提前编译直接吧\*.java文件编译成本地机器代码的过程.

-   前端编译器:Sun的Javac,Eclipse JDT中的增量式编译器
-   JIT编译器:HotSpot VM的C1,C2编译器
-   AOT编译器:GNU.......

文章后面介绍的都是第一类编译过程.

​		Java中即时编译器在运行期对字节码指令的优化对程序运行来说更重要,而前端编译器在编译期的优化过程对于程序编码而言更加密切(语法糖).

## 2、 Javac编译器

​		Javac编译器本身就是用Java语言编写的程序.

### 2.1 Javac的源码与调试

从Sun Javac的代码来看,编译过程大致可以分为3个过程:

-   解析与填充符号表
-   插入式注解处理器的注解处理
-   分析与字节码生成

### 2.2 解析与填充符号表

​		这一步包括了经典程序编译原理中的词法分析和语法分析两个过程:

#### 1). 词法,语法分析

​		词法分析是将源代码的字符流转变为标记集合,单个字符是程序源代码中的最小单位,而标记则是编译过程中的最小单位.(标记也就是单词,关键字,变量名,字面量,运算符等等都可以成为标记)

​		语法粉丝是根据标记序列构造抽象语法树的过程.抽象语法树是一种用来描述程序代码语法结构的树形表示方式.语法树中的每一个结点都代表程序代码中的一个语法结构.

​		经历过这个阶段后,编译期就基本不会在对源码文件进行操作了,后续的操作都是建立在语法树之上的.

#### 2). 填充符号表

​		完成了词法分析和语法分析之后就要进行填充符号表了.

​		符号表是由一组符号地址和符号信息构成的表格,可以想象成Map.符号表中所登记的信息在编译的不同阶段都要用到.在语义分析中符号表的内容用于语义检查和产生中间代码.目标代码生成阶段符号表是地址分配的依据.

### 2.3 注解处理器

​		在JDK 1.5之后Java提供了对注解的支持,JDK 1.6之后提供了一组插入式注解处理器的标准API在编译期间对注解进行处理.可以看做是一组编译期插件,可以读取,修改,添加抽象语法树中的任意元素.

​		每次对抽象语法树进行了修改,都会跳回填充符号表这一步重新进行编译操作.

### 2.4 语义分析与字节码生成

​		语法分析之后,编译期获得了程序源代码的抽象语法树,语法树能表示一个结构正确的源程序的抽象,但无法对源程序逻辑的正确性进行表示.

#### 1). 标注检查

​		Javac编译过程中,语义分析过程分为**<u>标注检查</u>**以及**<u>数据及控制流分析</u>**两个步骤.

​		标注检查步骤检查的内容包括变量使用前是否被声明,变量与赋值之间的数据类型是否匹配等等.

​		标注检查步骤中还有一个重要的过程被称为常量折叠.这个过程将所有类似"int a = 1 + 2"这样的代码全部折叠为"int a = 3".

#### 2). 数据及控制流分析

​		数据及控制流分析是对程序上下文逻辑更进一步的验证.

​		编译时期和类加载时期的数据及控制流分析的目的基本上是一致的,但范围有所区别.如final标注的成员变量就只在编译时期进行检查,编译过后不会保留final标注.

#### 3). 解语法糖

​		语法糖指在计算机语言中添加某种语法,这种语法对语言的功能并没有影响,但是更加方便程序员的使用.

​		在编译阶段还原回简单的基础语法的结构的过程成为解语法糖,

#### 4). 字节码生成

​		字节码生成是Javac编译过程的最后一个阶段.字节码生成阶段不仅仅是将前边各个步骤生成的信息(语法树,符号表)转化成字节码文件,还进行了少量的代码添加和转换.

​		例如之前提到的实例构造器\<init>()方法和类构造器\<clinit>()方法就是这个阶段添加到语法树中的.

## 3、 Java语法糖的味道

### 3.1 泛型与类型擦除

​		泛型是JDK 1.5的一项新特性,本质是参数化类型,也就是所操作的数据类型被制定为一个参数.

​		早期只能通过**<u>Object是所有类型父类和强制类型转换</u>**这两个特点配合来实现类型泛华.

​		Java中的泛型与C/C#中的泛型不一样,它**<u>只在源代码中存在,编译后就已经替换为原来的原生类型（伪泛型）</u>**.

​		Java中当泛型遇见重载.由于泛型在编译之后会恢复为原来的类型,那么就意味着不能通过泛型来作为不同的参数进行函数的重载.但是在Class文件中返回值还是方法特征签名的一部分,意味当返回值不同时,着这样的方法可以在Class文件中并存,可以进行重载.

### 3.2 自动装箱,拆箱与遍历循环

​		自动装箱是Integer.valueOf()的语法糖,在编译时期会将所有应该出现包装类的地方替换为前面的代码.

​		遍历循环的语法糖原型是使用迭代器的for循环,所以要求使用for-each循环的容器都实现Iterable接口.

### 3.3 条件编译

​		条件编译就是指在编译过程中根据一定条件对一些代码进行忽略.Java中的条件编译使用条件为常量的if语句实现.在编译阶段,常量的值一定是确定的.那么if语句中就会有一部分永远不会执行,编译器就不会编译这些代码.