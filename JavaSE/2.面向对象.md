------

[TOC]

------

# 1、类与对象概念

##  1.1 面向对象与面向过程

（1）面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。
（2）面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。

##  1.2 类与对象的概念

（1）类：对一类事物的描述，是抽象的、概念上的定义
（2）对象：是实际存在的该类事物的每个个体，因而也称为实例

（3）类与对象的关系：对象是类的实体，类是对象的抽象

# 2、类的结构

##  2.1 属性

- 类属性是可以直接通过“类名.属性名”来访问和修改。
- 类属性是这个类的所有实例对象所共有的属性。
- 直接定义在类的一对{}内
- 可以在声明属性时，指明其权限，使用权限修饰符（private、public、缺省、protected等）
- 类的属性，根据其类型，都默认初始化值
- 加载到堆空间中（非static）

**局部变量**

- 声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
- 不可以使用权限修饰符
- 没默认初始化值
- 加载到栈空间

## 2.2 方法

### 	2.2.1 方法的声明

```
权限修饰符  返回值类型  方法名(形参列表){
  			方法体
  }
```

### 	2.2.2 可变个数形参方法

```java
/*
 *可变个数形参的格式：数据类型 ... 变量名
 *当调用可变个数形参的方法时，传入的参数个数可以是：0-n个
 **/
public void test(String ... strs){	
		for(int i = 0;i < strs.length;i++){
			System.out.println(strs[i]);
		}
	}
```

###   2.2.3 java的值传递方式

（1）形参与实参

​		形参：方法定义时，声明的小括号内的参数

​		实参：方法调用时，实际传递给形参的数据

（2）基本数据类型与引用数据类型

​	基本数据类型的变量：赋值的是变量所保存的数据值。
​	引用数据类型的变量：赋值的是变量所保存的数据的地址值。

（3）值传递机制

​	如果变量是基本数据类型，此时赋值的是变量所保存的数据值。
​	如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。

### 2.2.4 递归方法

 	定义：一个方法体内调用它自身。



## 2.3 构造器（构造方法）

```
public 类名(形参列表){
		方法体
	}
```

###  2.3.1 作用

​	（1）创建对象

​	（2）初始化对象的信息

###  2.3.2 使用规则

- 如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器
- 定义构造器的格式：权限修饰符  类名(形参列表){}
- 一个类中定义的多个构造器，彼此构成重载
- 一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器
- 一个类中，至少会有一个构造器

### 2.3.3 属性赋值顺序

​	（1）默认初始化

​	（2）显式初始化

​	（3）构造器中初始化

​	（4）通过"对象.方法" 或 "对象.属性"的方式，赋值

### 2.3.4 JavaBean的概念

​	符合以下标准的Java类

-  是一个公共（public）的类 
- 有一个无参的公共的构造器
-  通过setXXX方法设置属性，通过getXXX方法获取属性 

## 2.4 代码块

- 代码块的作用：用来初始化类、对象的信息
- 分类：代码块要是使用修饰符，只能使用static
- 静态代码块作用：初始化类的信息。随着类的加载而执行,而且只执行一次
- 非静态代码块作用：可以在创建对象时，对对象的属性等进行初始化。创建一个对象，就执行一次非静态代码块
- 加载顺序：父类优先于子类，静态优先于非静态

## 2.5 内部类

​	定义：Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类。

###  2.5.1 分类

- 成员内部类（静态、非静态 ）
- 局部内部类(方法内、代码块内、构造器内)



# 3、重载与重写

##  3.1 重载与重写的概念

### 	3.1.1 重载的概念

​	**重载（Overload）**是让类以统一的方式处理不同类型数据的一种手段，实质表现就是多个具有不同的参数个数或者类型的同名函数（返回值类型可随意，不能以返回类型作为重载函数的区分标准）同时存在于同一个类中，是一个类中多态性的一种表现（调用方法时通过传递不同参数个数和参数类型来决定具体使用哪个方法的多态性）
### 3.1.2 重写的概念

​	**重写（Override）**是父类与子类之间的多态性，实质是对父类的函数进行重新定义，如果在子类中定义某方法与其父类有相同的名称和参数则该方法被重写，不过子类函数的访问修饰权限不能小于父类的；若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法，如需父类中原有的方法则可使用 super 关键字。
## 3.2 方法的重载

​	定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可

```java
public void getSum(int i,int j){
		System.out.println("1");
	}
	
public void getSum(double d1,double d2){
		System.out.println("2");
	}
```



###  3.2.1 重载的要求

- 必须具有不同的参数列表

- 可以有不同的返回类型

- 可以有不同的访问修饰符

- 可以抛出不同的异常 




## 3.3 方法的重写

​	定义： 又称覆盖 ，子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作

```java
class Circle{
public double findArea(){}//求面积
}

class Cylinder extends Circle{
public double findArea(){}//求表面积
}
```



###  3.3.2 重写的要求

- 参数列表必须完全与被重写的方法相同
- 返回类型必须一直与被重写的方法相同
- 访问修饰符的限制一定要大于等于被重写方法的访问修饰符
- 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常 

## 3.4 重载与重写的区别

###  3.4.1 目的不同

​	（1）重写：便于后期功能更新及维护，不必修改父类函数，在子类中就可以通过覆盖更新，提高了代码的拓展性。

​	（2）重载：方便阅读，优化了程序设计

### 3.4.2 "绑定"时间时间不同

​	（1）重载在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”

​	（2）重写等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”

# 4、关键字

##  4.1 this

​	理解：当前对象  或 当前正在创建的对象

###   4.1.1 this调用属性、方法

​		格式： **this.属性（方法）**

​	在类的方法中，我们可以使用"this.属性"或"this.方法"的方式，调用当前对象属性或方法。通常省略，如果构造器的形参和类的属性同名时，显式的表示

###   4.1.2 this调用构造器

​		格式：**this()**

​	在类的构造器中，可以显式的使用"this(形参列表)"方式，调用本类中指定的其他构造器

​	规则：

​			（1）不能通过"this(形参列表)"方式调用自己

​			（2）"this(形参列表)"必须声明在当前构造器的首行

​			（3）构造器内部，最多只能声明一个"this(形参列表)"

##  4.2 super

###   4.2.1 super调用属性、方法

​		格式： **super.属性（方法）**

​		在子类的方法或构造器中，通过使用"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。当**子类和父类中定义了同名的属性**时或者当**子类重写了父类中的方法**以后，在子类中调用父类中声明的属性必须显式使用super

###   4.2.2 super调用构造器

​		格式： **super()**

​	在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器

​		规则：

​			（1）"super(形参列表)"的使用，必须声明在子类构造器的首行

​			（2）针对于"this(形参列表)"或"super(形参列表)"只能二一，不能同时出现

​			（3）在构造器的首行，没显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器：super()

​			（4）在类的多个构造器中，至少一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器

##  4.3 package

​		使用package声明类或接口所属的包，声明在源文件的首行

### 	4.3.1 JDK中主要包的介绍

- java.lang：包含一些Java语言的核心类，如String
- java.net：包含执行与网络相关的操作的类和接口
- java.io：提供多种输入、输出功能的类
- java.util：包含一些实用的工具类
- java.text：包含一些Java格式化相关的类
- java.sql：包含了Java进行JDBC数据库编程相关的类
- java.awt：包含了构成抽象窗口的工具集

##  4.4 import 

​	 import就是在java文件开头的地方导入

- 在源文件中显式的使用import结构导入指定包下的类、接口
- 声明在包的声明和类的声明之间
- 可以使用"xxx.*"的方式，表示可以导入xxx包下的所有结构
- 如果使用的类或接口是java.lang包下定义的，则可以省略import结构
- 如果使用的类或接口是本包下定义的，则可以省略import结构
- 如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。
- 使用"xxx.*"方式表明可以调用xxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入
- import static:导入指定类或接口中的静态结构:属性或方法。 

## 4.5 static（静态的）

 	static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问 

###  4.5.1 static修饰属性：静态变量、类变量

 	静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。 

###  4.5.2 static修饰方法：静态方法、类方法

- ​	 static方法一般称作静态方法
- ​	静态方法不依赖于任何对象就可以进行访问
- ​	在静态方法中不能访问非静态成员方法和非静态成员变量
- ​	在非静态成员方法中是可以访问静态成员方法/变量的
- ​	在静态的方法内，不能使用this关键字、super关键字

###  4.5.3  static修饰代码块 

​	static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。

## 4.6 final（最终的）

- final 用来修饰一个类:此类不能被其他类所继承。比如：String类
- final 用来修饰方法：表明此方法不可以被重写。比如：Object类中getClass()
- final 用来修饰变量：此时的"变量"就称为是一个常量
- static final 用来修饰属性：全局常量

## 4.7 abstract（抽象的）

- abstract修饰类或方法
- 抽象类不能实例化
- 抽象方法只方法的声明，没方法体
- 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法
- 若子类重写了父类中的所的抽象方法后，此子类方可实例化
- abstract不能用来修饰：属性、构造器等结构
- abstract不能用来修饰私方法、静态方法、final的方法、final的类

## 4.8 interface（接口）

###  4.8.1 定义接口

- 接口使用interface来定义

- 定义接口中的成员（全局常量、抽象方法、静态方法）

- 接口中不能定义构造器的

- 接口与接口之间可以继承

### 4.8.2 接口新规范

- 接口中定义的静态方法，只能通过接口来调用

- 通过实现类的对象，可以调用接口中的默认方法

- 如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。

## 4.9 抽象类与接口的异同

###  4.9.1 相同点

- 都可以被继承

- 都不能被实例化

- 都包含抽象方法

- 都可以实现程序的多态性

### 4.9.2 不同点

- 抽象类用**abstract class**定义，接口用**interface**定义
- 抽象类是对事物更高级的封装，接口是对功能的实现
- 抽象类可以定义普通类能定义的所有方法 ，接口只能定义抽象方法、常量、静态方法、默认方法
- 抽象类是被子类**extends**继承，接口是被实现类**implement**实现
- 抽象类包括所有类都只支持**单继承**，接口支持**多继承**

# 5、面向对象的三大特性

##  5.1 封装性

###   5.1.1 封装的基本思想 

将对象的属性和行为封装起来，而将对象的属性和行为封装起来的载体是类，类通常对用户隐藏其实现的细节。

###   5.1.2 引入封装性的原因

​		（1）追求“高内聚，低耦合”

​				高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；

​				低耦合 ：仅对外暴露少量的方法用于使用。

​		（2）隐藏对象内部的复杂性，只对外公开简单的接口。

### 5.1.3 封装性的代码体现

- 将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值
- 不对外暴露的私有的方法
- 单例模式（将构造器私有化）
- 如果不希望类在包外被调用，可以将类设置为缺省的。

## 5.2 继承性

###  5.2.1 继承的基本思想 

​	使子类的对象拥有父类的全部属性和行为，同时可以增添自己的所特有的属性和行为。这样可以节省写共同具有的属性和方法代码的时间，有利于代码的复用。

###  5.2.2 继承的格式

```java
class A extends B{}
//A:子类、派生类、subclass
//B:父类、超类、基类、superclass
```

###  5.2.3 继承的目的

- 减少了代码的冗余，提高了代码的复用性
- 便于功能的扩展
- 为之后多态性的使用，提供了前提

### 5.2.4 Java中继承性的说明

- 子类继承父类后便拥有了父类的所有属性和方法
- 父类中的private的属性或方法也被子类继承，但因封装性的原因并不能直接调用
- 一个类可以被多个子类继承
- Java中类具有**单继承性**（一个类只能有一个父类）
- 子父类是相对的概念

## 5.3 多态性

###  5.3.1 多态性的概念

​		**父类的引用指向子类的对象**（或子类的对象赋给父类的引用）

### 5.3.2 多态性的使用

​	使用前提：类的继承和方法的重写

​	使用：虚拟方法调用，在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法

### 5.3.3 转型

​	![](G:\个人数据\笔记\JavaSE\img\006.jpg)

​	

​	（1）使用向下转型才能调用子类特有的属性和方法

​	（2）向下转型需要使用强制类型转换符：()

​	（3）向下转型先进行**instanceof**的判断，避免异常

​	（4）a instanceof A:判断对象a是否是类A的实例

# 6、Object类

## 6.1 Object类的概述

- Object类是所Java类的根父类

- 如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 

- Object类中的功能(属性、方法)就具通用性，Object类没有属性

- Object类只声明了一个空参的构造器

##  6.2 Object类的方法

- getClass()：返回此Object的运行时类
- hashCode() ：获取哈希码(int整数)，也称为散列码；作用是确定该对象在哈希表中的索引位置
- equals(Object obj)： 用来判断两个对象是否相等 
- clone()：本地clone方法,用于对象的复制
- toString()：返回该对象的字符串表示
- notify()/notifyAll()：唤醒在此对象监视器上等待的单个/所有线程
- wait()：当前线程等待
- finalize()：当垃圾回收期确定不存在对该对象的更多引用时,由对象的垃圾回收器调用此方法。

```java
/*返回此Object的运行时类*/
public final native Class<?> getClass();
/*
hashCode的常规协定是：
1.在java应用程序执行期间,在对同一对象多次调用hashCode()方法时,必须一致地返回相同的整数,前提是将对象进行equals比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行,该整数无需保持一致。
2.如果根据equals(object)方法,两个对象是相等的,那么对这两个对象中的每个对象调用hashCode方法都必须生成相同的整数结果。
3.如果根据equals(java.lang.Object)方法,两个对象不相等,那么对这两个对象中的任一对象上调用hashCode()方法不要求一定生成不同的整数结果。但是,程序员应该意识到,为不相等的对象生成不同整数结果可以提高哈希表的性能。
*/
public native int hashCode();
/*比较对象的内存地址,跟String.equals方法不同,它比较的只是对象的值*/
public boolean equals(Object obj) {
    return (this == obj);
}
/*本地clone方法,用于对象的复制*/
protected native Object clone() throws CloneNotSupportedException;
/*
返回该对象的字符串表示,非常重要的方法
getClass().getName();获取字节码文件的对应全路径名例如java.lang.Object
Integer.toHexString(hashCode());将哈希值转成16进制数格式的字符串。
*/
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
/*唤醒在此对象监视器上等待的单个线程*/
public final native void notify();
/*唤醒在此对象监视器上等待的所有线程*/
public final native void notifyAll();
/*
在其他线程调用此对象的notify()方法或notifyAll()方法前,导致当前线程等待。换句话说,此方法的行为就好像它仅执行wait(0)调用一样。
当前线程必须拥有此对象监视器。该线程发布对此监视器的所有权并等待,直到其他线程通过调用notify方法或notifyAll方法通知在此对象的监视器上等待的线程醒来,然后该线程将等到重新获得对监视器的所有权后才能继续执行。
*/
public final native void wait(long timeout) throws InterruptedException;
/*在其他线程调用此对象的notify()方法或notifyAll()方法,或者超过指定的时间量前,导致当前线程等待*/
public final void wait(long timeout, int nanos) throws InterruptedException {
    if (timeout < 0) {
        throw new IllegalArgumentException("timeout value is negative");
    }

    if (nanos < 0 || nanos > 999999) {
        throw new IllegalArgumentException(
                            "nanosecond timeout value out of range");
    }

    if (nanos > 0) {
        timeout++;
    }

    wait(timeout);
}

public final void wait() throws InterruptedException {
    wait(0);
}


/*当垃圾回收期确定不存在对该对象的更多引用时,由对象的垃圾回收器调用此方法。*/
protected void finalize() throws Throwable { }
```

## 6.3  == 和 equals() 区别

​	 ==比较的是引用，比较的是引用的地址值 ，equals方法，是object中的方法，如果不进行重写的话，比较的也是引用的地址值,实际和==一样 

## 6.4  hashCode()和equal() 

- ​	hashCode()和equal()作用一样， 在Java里都是用来对比两个对象是否相等一致 。
- ​	重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低 
- ​    hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样 
- ​	 hashCode() 在散列表中才有用 （ HashMap，Hashtable，HashSet ）

## 6.5 final、finally、finalize的区别

- final：用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可被继承 
- finally：作为异常处理的一部分，它只能用在try/catch语句中，并且附带着一个语句块，表示这段语句最终一定被执行，经常被用在需要释放资源的情况下。 
- finalize：是Object类中的一个方法，在垃圾收集器执行的时候会调用被回收对象的finalize（）方法，可以覆盖此方法来实现对其他资源的回收 

# 7、包装类

​	对于**基本数据类型**，Java提供了对应的包裹(wrap)类型。这些包裹类型将一个基本数据类型的数据转换成对象的形式，从而使得它们可以像对象一样参与运算和传递。下表列出了基本数据类型所对应的包裹类型：
| 基本类型 | 包裹类型  |
| -------- | --------- |
| boolean  | Boolean   |
| char     | Character |
| byte     | Byte      |
| short    | Short     |
| int      | Integer   |
| long     | Long      |
| float    | Float     |
| double   | Double    |